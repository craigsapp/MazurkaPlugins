<!---------------------------------------------------------------------------->
<html>
<head>
<title> Sig++ example program: MzSpectralFlatness.cpp </title>
<meta name="Document-Owner" content="Craig Sapp (craig@ccrma.stanford.edu)"> 
<meta name="Author" content="Craig Stuart Sapp (craig@ccrma.stanford.edu)">
<meta name="Creation-Date" content=" Tue May  9 19:38:11 PDT 2000 ">
<meta name="Revision-Date" content=" Tue Jan 16 09:38:43 PST 2007
 ">
</head>

<body bgcolor=#ffffff alink=#333399 link=#333399 vlink=#333399 text=#220000>
<!-- header *************************************************** -->

<center>
<table width=760 cellpadding=0 cellspacing=0 border=0>
<tr valign=top>
<td>
   <a href=http://www.charm.rhul.ac.uk><img alt="" border=0 src=../../images/logo.gif></a>
</td>
<td>
   <a href=http://mazurka.org.uk><img alt="" border=0 src=../../images/banner.gif></a>
</td>
</tr>
</table>
</center>

<center>
<table><tr><td>


<pre>
<font color=#229933>//</font>
<font color=#229933>// Programmer:    Craig Stuart Sapp &lt;craig@ccrma.stanford.edu&gt;</font>
<font color=#229933>// Creation Date: Sat Jan 13 05:29:01 PST 2007 (copied over from MzNevermore)</font>
<font color=#229933>// Last Modified: Sun Jan 14 08:13:38 PST 2007</font>
<font color=#229933>// Filename:      MzSpectralFlatness.cpp</font>
<font color=#229933>// URL:           <a href=http://sv.mazurka.org.uk/src/MzSpectralFlatness.cpp>http://sv.mazurka.org.uk/src/MzSpectralFlatness.cpp</a></font>
<font color=#229933>// Documentation: <a href=http://sv.mazurka.org.uk/MzSpectralFlatness>http://sv.mazurka.org.uk/MzSpectralFlatness</a></font>
<font color=#229933>// Syntax:        ANSI99 C++; vamp plugin</font>
<font color=#229933>//</font>
<font color=#229933>// Description:   Spectral flatness measurement plugin for vamp.</font>
<font color=#229933>//</font>

#define P_VER    "200701140"
#define P_NAME   "MzSpectralFlatness"

#include "MzSpectralFlatness.h" 
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

#include &lt;vector&gt;
#include &lt;string&gt;

using namespace std;


<font color=#229933>///////////////////////////////////////////////////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// Vamp Interface Functions</font>
<font color=#229933>//</font>


<font color=#229933>///////////////////////////////////////////////////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// Vamp Interface Functions</font>
<font color=#229933>//</font>
<a name=constructor>
</a><font color=#229933>///////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzSpectralFlatness::MzSpectralFlatness</b> -- class constructor.</font>
<font color=#229933>//</font>

MzSpectralFlatness::MzSpectralFlatness(float samplerate) : 
     <a name=MazurkaPlugin> </a><font color=#000000><b>MazurkaPlugin</b></font>(samplerate) {
   mz_transformsize =  1024;
   mz_minbin        =  0;
   mz_maxbin        =  511;
   mz_compress      =  0;
}


<a name=destructor>
</a><font color=#229933>///////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzSpectralFlatness::~MzSpectralFlatness</b> -- class destructor.</font>
<font color=#229933>//</font>

MzSpectralFlatness::~MzSpectralFlatness() {
   <font color=#229933>// do nothing</font>
}


<font color=#229933>////////////////////////////////////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// parameter functions --</font>
<font color=#229933>//</font>
<a name=getParameterDescriptors>
</a><font color=#229933>//////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzSpectralFlatness::getParameterDescriptors</b> -- return a list of</font>
<font color=#229933>//      the parameters which can control the plugin.</font>
<font color=#229933>//</font>
<font color=#229933>// </font>
<font color=#229933>//    "windowsamples"    -- number of samples in audio window</font>
<font color=#229933>//    "transformsamples" -- number of samples in transform</font>
<font color=#229933>//    "stepsamples"      -- number of samples between analysis windows</font>
<font color=#229933>//    "minbin"           -- lowest transform bin to display</font>
<font color=#229933>//    "maxbin"           -- highest transform bin to display</font>

MzSpectralFlatness::ParameterList 
MzSpectralFlatness::getParameterDescriptors(void) const {

   ParameterList       pdlist;
   ParameterDescriptor pd;

   <font color=#229933>// first parameter: The number of samples in the audio window</font>
   pd.name         = "windowsamples";
   pd.description  = "Window size";
   pd.unit         = "samples";
   pd.minValue     = 2.0;
   pd.maxValue     = 20000.0;
   pd.defaultValue = 512.0;
   pd.isQuantized  = true;
   pd.quantizeStep = 1.0;
   pdlist.push_back(pd);

   <font color=#229933>// second parameter: The number of samples in the DFT transform</font>
   pd.name         = "transformsamples";
   pd.description  = "Transform size";
   pd.unit         = "samples";
   pd.minValue     = 2.0;
   pd.maxValue     = 100000.0;
   pd.defaultValue = 512.0;
   pd.isQuantized  = true;
   pd.quantizeStep = 1.0;
   pdlist.push_back(pd);

   <font color=#229933>// third parameter: The step size between analysis windows.</font>
   pd.name         = "stepsamples";
   pd.description  = "Step size";
   pd.unit         = "samples";
   pd.minValue     = 2.0;
   pd.maxValue     = 300000.0;
   pd.defaultValue = 441.0; 
   pd.isQuantized  = true;
   pd.quantizeStep = 1.0;
   pdlist.push_back(pd);

   <font color=#229933>// fourth parameter: The minimum bin number to display.</font>
   <font color=#229933>// Note: must be less or equal to the maximum bin size.</font>
   <font color=#229933>// This will be enforced in the initialise() function.</font>
   pd.name         = "minbin";
   pd.description  = "Min spectral bin";
   pd.unit         = "bin";
   pd.minValue     = 0.0;
   pd.maxValue     = 30000.0;
   pd.defaultValue = 0.0; 
   pd.isQuantized  = true;
   pd.quantizeStep = 1.0;
   pdlist.push_back(pd);

   <font color=#229933>// fifth parameter: The minimum bin number to display in terms</font>
   <font color=#229933>// of frequency.  This will override "minbin" if set to a value</font>
   <font color=#229933>// other than 0.0;</font>
   pd.name         = "minfreq";
   pd.description  = "         or in Hz:";
   pd.unit         = "Hz";
   pd.minValue     = 0.0;
   pd.maxValue     = getSrate()/2.0;
   pd.defaultValue = 0.0;
   pd.isQuantized  = false;
   <font color=#229933>//pd.quantizeStep = 1.0;</font>
   pdlist.push_back(pd);

   <font color=#229933>// sixth parameter: The maximum bin number to display.</font>
   <font color=#229933>// Note: must be greater or equal to the mininimum bin size,</font>
   <font color=#229933>// and smaller than the transform size.  This will</font>
   <font color=#229933>// be enforced in the initialise() function.</font>
   pd.name         = "maxbin";
   pd.description  = "Max spectral bin";
   pd.unit         = "bin";
   pd.minValue     = 0.0;
   pd.maxValue     = 30000.0;
   pd.defaultValue = 2048.0;   
   pd.isQuantized  = true;
   pd.quantizeStep = 1.0;
   pdlist.push_back(pd);

   <font color=#229933>// seventh parameter: The maximum bin number to display in </font>
   <font color=#229933>// terms of frequency.  This will override "maxbin" if set</font>
   <font color=#229933>// to a value other than 0.0</font>
   pd.name         = "maxfreq";
   pd.description  = "         or in Hz:";
   pd.unit         = "Hz";
   pd.minValue     = 0.0;
   pd.maxValue     = getSrate()/2.0;
   pd.defaultValue = pd.minValue;
   pd.isQuantized  = false;
   <font color=#229933>// pd.quantizeStep = 1.0;</font>
   pdlist.push_back(pd);

<font color=#992233>/*   <font color=#229933>// eighth parameter: Magnitude range compression.</font>
   pd.name         = "compress";
   pd.description  = "Compress range";
   pd.unit         = "";
   pd.minValue     = 0.0;
   pd.maxValue     = 1.0;
   pd.defaultValue = 1.0;
   pd.valueNames.push_back("no");
   pd.valueNames.push_back("yes");
   pd.isQuantized  = true;
   pd.quantizeStep = 1.0;
   pdlist.push_back(pd);
   pd.valueNames.clear();
*/</font>

   <font color=#229933>// ninth parameter: Signal windowing method</font>
   pd.name         = "windowtype";
   pd.description  = "Window type";
   pd.unit         = "";
   MazurkaWindower::getWindowList(pd.valueNames);
   pd.minValue     = 1.0;
   pd.maxValue     = pd.valueNames.size();
   pd.defaultValue = 2.0;                   <font color=#229933>// probably the Hann window</font>
   pd.isQuantized  = true;
   pd.quantizeStep = 1.0;
   pdlist.push_back(pd);
   pd.valueNames.clear();

   <font color=#229933>// tenth parameter: Smoothing gain</font>
   pd.name         = "smooth";
   pd.description  = "Smoothing";
   pd.unit         = "";
   pd.minValue     = 0.0;
   pd.maxValue     = 0.999;
   pd.defaultValue = 0.95;
   pd.isQuantized  = false;
   <font color=#229933>//pd.quantizeStep = 1.0;</font>
   pdlist.push_back(pd);
   pd.valueNames.clear();

   return pdlist;
}


<font color=#229933>////////////////////////////////////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// optional polymorphic functions inherited from PluginBase:</font>
<font color=#229933>//</font>
<a name=getPreferredStepSize>
</a><font color=#229933>//////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzSpectralFlatness::getPreferredStepSize</b> -- overrides the </font>
<font color=#229933>//     default value of 0 (no preference) returned in the </font>
<font color=#229933>//     inherited plugin class.</font>
<font color=#229933>//</font>

size_t MzSpectralFlatness::getPreferredStepSize(void) const {
   return getParameterInt("stepsamples");
}


<a name=getPreferredBlockSize>
</a><font color=#229933>//////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzSpectralFlatness::getPreferredBlockSize</b> -- overrides the </font>
<font color=#229933>//     default value of 0 (no preference) returned in the </font>
<font color=#229933>//     inherited plugin class.</font>
<font color=#229933>//</font>

size_t MzSpectralFlatness::getPreferredBlockSize(void) const {
 
   int transformsize = getParameterInt("transformsamples");
   int blocksize     = getParameterInt("windowsamples");

   if (blocksize &gt; transformsize) {
      blocksize = transformsize;
   }

   return blocksize;
}


<font color=#229933>////////////////////////////////////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// required polymorphic functions inherited from PluginBase:</font>
<font color=#229933>//</font>

std::string MzSpectralFlatness::getName(void) const
   { return "mzspectralflatness"; }

std::string MzSpectralFlatness::getMaker(void) const
   { return "The Mazurka Project"; }

std::string MzSpectralFlatness::getCopyright(void) const
   { return "2007 Craig Stuart Sapp"; }

std::string MzSpectralFlatness::getDescription(void) const
   { return "Spectral Flatness"; }

int MzSpectralFlatness::getPluginVersion(void) const {
   const char *v = "@@VampPluginID@" P_NAME "@" P_VER "@" __DATE__ "@@";
   if (v[0] != '@') { std::cerr &lt;&lt; v &lt;&lt; std::endl; return 0; }
   return atol(P_VER);
}


<font color=#229933>////////////////////////////////////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// required polymorphic functions inherited from Plugin:</font>
<font color=#229933>//</font>
<a name=getInputDomain>
</a><font color=#229933>//////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzSpectralFlatness::getInputDomain</b> -- the host application needs</font>
<font color=#229933>//    to know if it should send either:</font>
<font color=#229933>//</font>
<font color=#229933>// TimeDomain      == Time samples from the audio waveform.</font>
<font color=#229933>// FrequencyDomain == Spectral frequency frames which will arrive</font>
<font color=#229933>//                    in an array of interleaved real, imaginary</font>
<font color=#229933>//                    values for the complex spectrum (both positive </font>
<font color=#229933>//                    and negative frequencies). Zero Hz being the</font>
<font color=#229933>//                    first frequency sample and negative frequencies</font>
<font color=#229933>//                    at the far end of the array as is usually done.</font>
<font color=#229933>//                    Note that frequency data is transmitted from</font>
<font color=#229933>//                    the host application as floats.  The data will</font>
<font color=#229933>//                    be transmitted via the process() function which</font>
<font color=#229933>//                    is defined further below.</font>
<font color=#229933>//</font>

MzSpectralFlatness::InputDomain MzSpectralFlatness::getInputDomain(void) const {
   return TimeDomain; 
}


<a name=getOutputDescriptors>
</a><font color=#229933>//////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzSpectralFlatness::getOutputDescriptors</b> -- return a list describing</font>
<font color=#229933>//    each of the available outputs for the object.  OutputList</font>
<font color=#229933>//    is defined in the file vamp-sdk/Plugin.h:</font>
<font color=#229933>//</font>
<font color=#229933>// .name             == short name of output for computer use.  Must not</font>
<font color=#229933>//                      contain spaces or punctuation.</font>
<font color=#229933>// .description      == long name of output for human use.</font>
<font color=#229933>// .unit             == the units or basic meaning of the data in the </font>
<font color=#229933>//                      specified output.</font>
<font color=#229933>// .hasFixedBinCount == true if each output feature (sample) has the </font>
<font color=#229933>//                      same dimension.</font>
<font color=#229933>// .binCount         == when hasFixedBinCount is true, then this is the </font>
<font color=#229933>//                      number of values in each output feature.  </font>
<font color=#229933>//                      binCount=0 if timestamps are the only features,</font>
<font color=#229933>//                      and they have no labels.</font>
<font color=#229933>// .binNames         == optional description of each bin in a feature.</font>
<font color=#229933>// .hasKnownExtent   == true if there is a fixed minimum and maximum</font>
<font color=#229933>//                      value for the range of the output.</font>
<font color=#229933>// .minValue         == range minimum if hasKnownExtent is true.</font>
<font color=#229933>// .maxValue         == range maximum if hasKnownExtent is true.</font>
<font color=#229933>// .isQuantized      == true if the data values are quantized.  Ignored</font>
<font color=#229933>//                      if binCount is set to zero.</font>
<font color=#229933>// .quantizeStep     == if isQuantized, then the size of the quantization,</font>
<font color=#229933>//                      such as 1.0 for integers.</font>
<font color=#229933>// .sampleType       == Enumeration with three possibilities:</font>
<font color=#229933>//   OD::OneSamplePerStep   -- output feature will be aligned with</font>
<a name=VariableSampleRate><font color=#229933>//                             the beginning time of the input block data.</font>
</a><font color=#229933>//   OD::FixedSampleRate    -- results are evenly spaced according to </font>
<font color=#229933>//                             .sampleRate (see below).</font>
<font color=#229933>//   <b>OD::VariableSampleRate</b> -- output features have individual timestamps.</font>
<font color=#229933>// .sampleRate       == samples per second spacing of output features when</font>
<font color=#229933>//                      sampleType is set toFixedSampleRate.</font>
<font color=#229933>//                      Ignored if sampleType is set to OneSamplePerStep</font>
<font color=#229933>//                      since the start time of the input block will be used.</font>
<font color=#229933>//                      Usually set the sampleRate to 0.0 if VariableSampleRate</font>
<font color=#229933>//                      is used; otherwise, see vamp-sdk/Plugin.h for what</font>
<font color=#229933>//                      positive sampleRates would mean.</font>
<font color=#229933>//</font>

MzSpectralFlatness::OutputList 
MzSpectralFlatness::getOutputDescriptors(void) const {

   OutputList       odlist;
   OutputDescriptor od;


   <font color=#229933>// First output channel: The raw spectral flatness values</font>
   od.name             = "rawflatness";
   od.description      = "Spectral Flatness Function";
   od.unit             = "";
   od.hasFixedBinCount = true;
   od.binCount         = 1;
   od.hasKnownExtents  = false;
   <font color=#229933>// od.minValue      = 0.0;</font>
   <font color=#229933>// od.maxValue      = 1.0;</font>
   od.isQuantized      = false;
   <font color=#229933>// od.quantizeStep  = 1.0;</font>
   od.sampleType       = OutputDescriptor::OneSamplePerStep;
   <font color=#229933>// od.sampleRate    = 0.0;</font>
   #define OUTPUT_FLATNESS_CURVE 0
   odlist.push_back(od);
   od.binNames.clear();

   <font color=#229933>// Second output channel: The smoothed spectral flatness values</font>
   od.name             = "smoothedflatness";
   od.description      = "Smoothed Spectral Flatness Function";
   od.unit             = "";
   od.hasFixedBinCount = true;
   od.binCount         = 1;
   od.hasKnownExtents  = false;
   <font color=#229933>// od.minValue      = 0.0;</font>
   <font color=#229933>// od.maxValue      = 1.0;</font>
   od.isQuantized      = false;
   <font color=#229933>// od.quantizeStep  = 1.0;</font>
   od.sampleType       = OutputDescriptor::VariableSampleRate;
   <font color=#229933>// od.sampleRate    = 0.0;</font>
   #define OUTPUT_FLATNESS_SMOOTH 1
   odlist.push_back(od);
   od.binNames.clear();

   <font color=#229933>// Third output channel: The geometric mean of the audio signal</font>
   od.name             = "geometric mean";
   od.description      = "Geometric Mean";
   od.unit             = "";
   od.hasFixedBinCount = true;
   od.binCount         = 1;
   od.hasKnownExtents  = false;
   <font color=#229933>// od.minValue      = 0.0;</font>
   <font color=#229933>// od.maxValue      = 1.0;</font>
   od.isQuantized      = false;
   <font color=#229933>// od.quantizeStep  = 1.0;</font>
   od.sampleType       = OutputDescriptor::OneSamplePerStep;
   <font color=#229933>// od.sampleRate    = 0.0;</font>
   #define OUTPUT_GEOMETRIC_MEAN 2
   odlist.push_back(od);
   od.binNames.clear();

   <font color=#229933>// Fourth output channel: The arithmeticmean of the audio signal</font>
   od.name             = "arithmeticmean";
   od.description      = "Arithmetic Mean";
   od.unit             = "";
   od.hasFixedBinCount = true;
   od.binCount         = 1;
   od.hasKnownExtents  = false;
   <font color=#229933>// od.minValue      = 0.0;</font>
   <font color=#229933>// od.maxValue      = 1.0;</font>
   od.isQuantized      = false;
   <font color=#229933>// od.quantizeStep  = 1.0;</font>
   od.sampleType       = OutputDescriptor::OneSamplePerStep;
   <font color=#229933>// od.sampleRate    = 0.0;</font>
   #define OUTPUT_ARITHMETIC_MEAN 3
   odlist.push_back(od);
   od.binNames.clear();

   return odlist; 
}


<a name=initialise>
</a><font color=#229933>//////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzSpectralFlatness::initialise</b> -- this function is called once</font>
<font color=#229933>//     before the first call to process().</font>
<font color=#229933>//</font>

bool MzSpectralFlatness::initialise(size_t channels, size_t stepsize, 
      size_t blocksize) {

   if (channels &lt; getMinChannelCount() || channels &gt; getMaxChannelCount()) {
      return false;
   }

   <font color=#229933>// step size and block size should never be zero</font>
   if (stepsize &lt;= 0 || blocksize &lt;= 0) {
      return false;
   }

   setChannelCount(channels);
   setStepSize(stepsize);
   setBlockSize(blocksize);

   mz_compress      = getParameterInt("compress");
   mz_transformsize = getParameterInt("transformsamples");
   mz_minbin        = getParameterInt("minbin");
   mz_maxbin        = getParameterInt("maxbin");
   mz_smooth        = getParameterDouble("smooth");

   if (getParameter("minfreq") &gt; 0.0) {
      <font color=#229933>// rounding down to the lower integer value</font>
      mz_minbin = int(getParameter("minfreq") / (getSrate()/mz_transformsize));
   }
   if (getParameter("maxfreq") &gt; 0.0) {
      <font color=#229933>// rounding up to the next higher integer value</font>
      mz_maxbin = int(getParameter("maxfreq") / 
                      (getSrate()/mz_transformsize) + 0.999);
   }

   if (mz_maxbin &gt;= mz_transformsize) { mz_maxbin = mz_transformsize / 2 - 1; }
   if (mz_minbin &gt;= mz_transformsize) { mz_minbin = mz_transformsize / 2 - 1; }
   if (mz_minbin &gt; mz_maxbin)         { std::swap(mz_minbin, mz_maxbin); }
   if (mz_minbin &lt; 0)                 { mz_minbin = 0; }
   if (mz_maxbin &lt; 0)                 { mz_maxbin = 0; }

   mz_transformer.setSize(mz_transformsize);
   mz_windower.setSize(getBlockSize());
   mz_windower.makeWindow(getParameterString("windowtype"));

   <font color=#229933>// std::cerr &lt;&lt; "MzSpectralFlatness::initialize : window is set to " </font>
   <font color=#229933>//           &lt;&lt; getParameterString("windowtype") &lt;&lt; std::endl;</font>


   flatness_curve.clear();
   flatness_times.clear();

   return true;
}


<a name=process>
</a><font color=#229933>//////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzSpectralFlatness::process</b> -- This function is called sequentially on the </font>
<font color=#229933>//    input data, block by block.  After the sequence of blocks has been</font>
<font color=#229933>//    processed with process(), the function getRemainingFeatures() will </font>
<font color=#229933>//    be called.</font>
<font color=#229933>//</font>
<font color=#229933>// Here is a reference chart for the Feature struct:</font>
<font color=#229933>//</font>
<font color=#229933>// .hasTimestamp   == If the OutputDescriptor.sampleType is set to</font>
<font color=#229933>//                    VariableSampleRate, then this should be "true".</font>
<font color=#229933>// .timestamp      == The time at which the feature occurs in the time stream.</font>
<font color=#229933>// .values         == The float values for the feature.  Should match</font>
<font color=#229933>//                    OD::binCount.</font>
<font color=#229933>// .label          == Text associated with the feature (for time instants).</font>
<font color=#229933>//</font>

<font color=#229933>// #define sigmoidscale(x,c,w)  (1.0/(1.0+exp(-((x)-(c))/((w)/8.0))))</font>

MzSpectralFlatness::FeatureSet MzSpectralFlatness::process(AUDIODATA inputbufs, 
      Vamp::RealTime timestamp) {

   if (getStepSize() &lt;= 0) {
      std::cerr &lt;&lt; "ERROR: MzSpectralFlatness::process: "
                &lt;&lt; "MzSpectralFlatness has not been initialized"
                &lt;&lt; std::endl;
      return FeatureSet();
   }

   FeatureSet returnFeatures;
   Feature feature;

   feature.hasTimestamp = false;

   mz_windower.windowNonCausal(mz_transformer, inputbufs[0], getBlockSize());
   mz_transformer.doTransform();

   int bincount = mz_maxbin - mz_minbin + 1;
   
   vector&lt;double&gt; magnitude;
   magnitude.resize(bincount);

   int i;
   for (i=0; i&lt;bincount; i++) {
      magnitude[i] = mz_transformer.getSpectrumMagnitude(i + mz_minbin);
   }

   <font color=#229933>// double sflat = getSpectralFlatness(magnitude);</font>
   double sflat;
   double arithmeticmean = getArithmeticMean(magnitude);
   double geometricmean  = getGeometricMean(magnitude);
   if (arithmeticmean == 0.0) {
      sflat = 0.0;
   } else {
      sflat = geometricmean / arithmeticmean;
   }

   feature.hasTimestamp = false;
   feature.values.clear();
   feature.values.push_back(sflat);
   returnFeatures[OUTPUT_FLATNESS_CURVE].push_back(feature);

   feature.hasTimestamp = false;
   feature.values.clear();
   feature.values.push_back(geometricmean);
   returnFeatures[OUTPUT_GEOMETRIC_MEAN].push_back(feature);

   feature.hasTimestamp = false;
   feature.values.clear();
   feature.values.push_back(arithmeticmean);
   returnFeatures[OUTPUT_ARITHMETIC_MEAN].push_back(feature);

   <font color=#229933>// store value for smoothing later in getRemainingFeatures</font>
   flatness_curve.push_back(sflat);
   flatness_times.push_back(timestamp);
   

   return returnFeatures;
}


<a name=getRemainingFeatures>
</a><font color=#229933>//////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzSpectralFlatness::getRemainingFeatures</b> -- This function is called</font>
<font color=#229933>//    after the last call to process() on the input data stream has </font>
<font color=#229933>//    been completed.  Features which are non-causal can be calculated </font>
<font color=#229933>//    at this point.  See the comment above the process() function</font>
<font color=#229933>//    for the format of output Features.</font>
<font color=#229933>//</font>

MzSpectralFlatness::FeatureSet MzSpectralFlatness::getRemainingFeatures(void) {

   FeatureSet returnFeatures;
   Feature feature;

   feature.hasTimestamp = true;

   smoothSequence(flatness_curve, mz_smooth);
   int i;
   int size = (int)flatness_curve.size();
   for (i=0; i&lt;size; i++) {
      feature.values.clear();
      feature.timestamp = flatness_times[i];
      feature.values.push_back(flatness_curve[i]);
      returnFeatures[OUTPUT_FLATNESS_SMOOTH].push_back(feature);
   }

   return returnFeatures;
}


<a name=reset>
</a><font color=#229933>//////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzSpectralFlatness::reset</b> -- This function may be called after data processing</font>
<font color=#229933>//    has been started with the process() function.  It will be called when</font>
<font color=#229933>//    processing has been interrupted for some reason and the processing</font>
<font color=#229933>//    sequence needs to be restarted (and current analysis output thrown out).  </font>
<font color=#229933>//    After this function is called, process() will start at the beginning</font>
<font color=#229933>//    of the input selection as if initialise() had just been called.</font>
<font color=#229933>//    Note, however, that initialise() will NOT be called before processing </font>
<font color=#229933>//    is restarted after a reset().</font>
<font color=#229933>//</font>

void MzSpectralFlatness::reset(void) {
   flatness_curve.clear();
   flatness_times.clear();
}


<font color=#229933>///////////////////////////////////////////////////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// Non-Interface Functions </font>
<font color=#229933>//</font>
<a name=getSpectralFlatness>
</a><font color=#229933>//////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzSpectralFlatness::getSpectralFlatness</b> --</font>
<font color=#229933>//</font>

double MzSpectralFlatness::getSpectralFlatness(vector&lt;double&gt;& sequence) {
   double arithmeticmean = getArithmeticMean(sequence);
   if (arithmeticmean == 0.0) {
      return 0.0;
   }
   double geometricmean  = getGeometricMean(sequence);
   return geometricmean / arithmeticmean;
}



<a name=getGeometricMean>
</a><font color=#229933>//////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzSpectralFlatness::getGeometricMean</b> -- Ignore zero bins.</font>
<font color=#229933>//</font>

double MzSpectralFlatness::getGeometricMean(vector&lt;double&gt;& sequence) {
   int i;
   int size = (int)sequence.size();
   int count = 0;
   for (i=0; i&lt;size; i++) {
      if (sequence[i] != 0.0) {
         count++;
      }
   }

   if (count == 0) {
      return 0.0;
   }

   double power = 1.0 / count;

   double product = 1.0;
   for (i=0; i&lt;size; i++) {
      if (sequence[i] == 0.0) {
         continue;
      }
      product *= pow(sequence[i], power);
   }

   return product;
}



<a name=getArithmeticMean>
</a><font color=#229933>//////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzSpectralFlatness::getArithmeticMean</b> -- Ignore zero bins.</font>
<font color=#229933>//</font>

double MzSpectralFlatness::getArithmeticMean(vector&lt;double&gt;& sequence) {
   int i;
   int size = (int)sequence.size();
   int count = 0;
   for (i=0; i&lt;size; i++) {
      if (sequence[i] != 0.0) {
         count++;
      }
   }

   if (count == 0) {
      return 0.0;
   }

   double sum = 0.0;
   for (i=0; i&lt;size; i++) {
      sum += sequence[i];
   }

   return sum / count;
}



<a name=smoothSequence>
</a><font color=#229933>//////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzSpectralFlatness::smoothSequence</b> -- smooth the sequence with a</font>
<font color=#229933>//    symmetric exponential smoothing filter (applied in the forward</font>
<font color=#229933>//    and reverse directions with the specified input gain.</font>
<font color=#229933>//</font>
<font color=#229933>//    Difference equation for smoothing: y[n] = k * x[n] + (1-k) * y[n-1]</font>
<font color=#229933>//</font>

void MzSpectralFlatness::smoothSequence(vector&lt;double&gt;& sequence, double gain) {
   double oneminusgain = 1.0 - gain;
   int i;
   int ssize = sequence.size();

   <font color=#229933>// reverse filtering first </font>
   for (i=ssize-2; i&gt;=0; i--) {
      sequence[i] = gain*sequence[i] + oneminusgain*sequence[i+1];
   }

   <font color=#229933>// then forward filtering</font>
   for (i=1; i&lt;ssize; i++) {
      sequence[i] = gain*sequence[i] + oneminusgain*sequence[i-1];
   }

}









</pre>


</td></tr>
</table>
</center>




</body>
</html>
   
