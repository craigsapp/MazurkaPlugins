<!---------------------------------------------------------------------------->
<html>
<head>
<title> Sig++ example program: MzSpectrogramFFTW.cpp </title>
<meta name="Document-Owner" content="Craig Sapp (craig@ccrma.stanford.edu)"> 
<meta name="Author" content="Craig Stuart Sapp (craig@ccrma.stanford.edu)">
<meta name="Creation-Date" content=" Tue May  9 19:38:11 PDT 2000 ">
<meta name="Revision-Date" content=" Wed Dec 27 07:42:42 PST 2006
 ">
</head>

<body bgcolor=#ffffff alink=#333399 link=#333399 vlink=#333399 text=#220000>
<!-- header *************************************************** -->

<center>
<table width=760 cellpadding=0 cellspacing=0 border=0>
<tr valign=top>
<td>
   <a href=http://www.charm.rhul.ac.uk><img alt="" border=0 src=../../images/logo.gif></a>
</td>
<td>
   <a href=http://mazurka.org.uk><img alt="" border=0 src=../../images/banner.gif></a>
</td>
</tr>
</table>
</center>

<center>
<table><tr><td>


<pre>
<font color=#229933>//</font>
<font color=#229933>// Programmer:    Craig Stuart Sapp &lt;craig@ccrma.stanford.edu&gt;</font>
<font color=#229933>// Creation Date: Sun Jun 11 21:04:49 PDT 2006</font>
<font color=#229933>// Last Modified: Fri Jun 23 01:45:07 PDT 2006 (subclassed to MazurkaPlugin)</font>
<font color=#229933>// Filename:      MzSpectrogramFFTW.cpp</font>
<font color=#229933>// URL:           <a href=http://sv.mazurka.org.uk/src/MzSpectrogramFFTW.cpp>http://sv.mazurka.org.uk/src/MzSpectrogramFFTW.cpp</a></font>
<font color=#229933>// Documentation: <a href=http://sv.mazurka.org.uk/MzSpectrogramFFTW>http://sv.mazurka.org.uk/MzSpectrogramFFTW</a></font>
<font color=#229933>// Syntax:        ANSI99 C++; vamp 0.9 plugin</font>
<font color=#229933>//</font>
<font color=#229933>// Description:   Demonstration of how to create spectral data from time data</font>
<font color=#229933>//                supplied by the host application using the FFTW library</font>
<font color=#229933>//                for Fourier Transforms.</font>
<font color=#229933>//</font>


#include "MzSpectrogramFFTW.h" 

#include &lt;math.h&gt;


<font color=#229933>///////////////////////////////////////////////////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// Vamp Interface Functions</font>
<font color=#229933>//</font>
<a name=constructor>
</a><font color=#229933>///////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzSpectrogramFFTW::MzSpectrogramFFTW</b> -- class constructor.</font>
<font color=#229933>//</font>

MzSpectrogramFFTW::MzSpectrogramFFTW(float samplerate) : 
     <a name=MazurkaPlugin> </a><font color=#000000><b>MazurkaPlugin</b></font>(samplerate) {
   mz_minbin    = 0;
   mz_maxbin    = 0;
   mz_wind_buff = NULL;
}


<a name=destructor>
</a><font color=#229933>///////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzSpectrogramFFTW::~MzSpectrogramFFTW</b> -- class destructor.</font>
<font color=#229933>//</font>

MzSpectrogramFFTW::~MzSpectrogramFFTW() {
   delete [] mz_wind_buff;
}


<font color=#229933>////////////////////////////////////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// required polymorphic functions inherited from PluginBase:</font>
<font color=#229933>//</font>

std::string MzSpectrogramFFTW::getName(void) const
   { return "mzspectrogramfftw"; }

std::string MzSpectrogramFFTW::getMaker(void) const
   { return "The Mazurka Project"; }

std::string MzSpectrogramFFTW::getCopyright(void) const
   { return "2006 Craig Stuart Sapp"; }

std::string MzSpectrogramFFTW::getDescription(void) const
   { return "FFTW Spectrogram"; }

int MzSpectrogramFFTW::getPluginVersion(void) const {
   #define P_VER    "200606260"
   #define P_NAME   "MzSpectrogramFFTW"

   const char *v = "@@VampPluginID@" P_NAME "@" P_VER "@" __DATE__ "@@";
   if (v[0] != '@') { std::cerr &lt;&lt; v &lt;&lt; std::endl; return 0; }
   return atol(P_VER);
}



<font color=#229933>////////////////////////////////////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// optional polymorphic parameter functions inherited from PluginBase:</font>
<font color=#229933>//</font>
<font color=#229933>// Note that the getParameter() and setParameter() polymorphic functions</font>
<font color=#229933>// are handled in the MazurkaPlugin class.</font>
<font color=#229933>//</font>
<a name=getParameterDescriptors>
</a><font color=#229933>//////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzSpectrogramFFTW::getParameterDescriptors</b> -- return a list of</font>
<font color=#229933>//      the parameters which can control the plugin.</font>
<font color=#229933>//</font>

MzSpectrogramFFTW::ParameterList
MzSpectrogramFFTW::getParameterDescriptors(void) const {

   ParameterList       pdlist;
   ParameterDescriptor pd;

   <font color=#229933>// first parameter: The minimum spectral bin to display</font>
   pd.name         = "minbin";
   pd.description  = "Minimum\nfrequency\nbin";
   pd.unit         = "";
   pd.minValue     = 0.0;
   pd.maxValue     = 30000.0;
   pd.defaultValue = 0.0;
   pd.isQuantized  = 1;
   pd.quantizeStep = 1.0;
   pdlist.push_back(pd);

   <font color=#229933>// second parameter: The maximum spectral bin to display</font>
   pd.name         = "maxbin";
   pd.description  = "Maximum\nfrequency\nbin";
   pd.unit         = "";
   pd.minValue     = -1.0;
   pd.maxValue     = 30000.0;
   pd.defaultValue = -1.0;
   pd.isQuantized  = 1;
   pd.quantizeStep = 1.0;
   pdlist.push_back(pd);

   return pdlist;
}


<font color=#229933>////////////////////////////////////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// required polymorphic functions inherited from Plugin:</font>
<font color=#229933>//</font>
<a name=getInputDomain>
</a><font color=#229933>//////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzSpectrogramFFTW::getInputDomain</b> -- the host application needs</font>
<font color=#229933>//    to know if it should send either:</font>
<font color=#229933>//</font>
<font color=#229933>// TimeDomain      == Time samples from the audio waveform.</font>
<font color=#229933>// FrequencyDomain == Spectral frequency frames which will arrive</font>
<font color=#229933>//                    in an array of interleaved real, imaginary</font>
<font color=#229933>//                    values for the complex spectrum (both positive </font>
<font color=#229933>//                    and negative frequencies). Zero Hz being the</font>
<font color=#229933>//                    first frequency sample and negative frequencies</font>
<font color=#229933>//                    at the far end of the array as is usually done.</font>
<font color=#229933>//                    Note that frequency data is transmitted from</font>
<font color=#229933>//                    the host application as floats.  The data will</font>
<font color=#229933>//                    be transmitted via the process() function which</font>
<font color=#229933>//                    is defined further below.</font>
<font color=#229933>//</font>

MzSpectrogramFFTW::InputDomain MzSpectrogramFFTW::getInputDomain(void) const { 
   return TimeDomain; 
}


<a name=getOutputDescriptors>
</a><font color=#229933>//////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzSpectrogramFFTW::getOutputDescriptors</b> -- return a list describing</font>
<font color=#229933>//    each of the available outputs for the object.  OutputList</font>
<font color=#229933>//    is defined in the file vamp-sdk/Plugin.h:</font>
<font color=#229933>//</font>
<font color=#229933>// .name             == short name of output for computer use.  Must not</font>
<font color=#229933>//                      contain spaces or punctuation.</font>
<font color=#229933>// .description      == long name of output for human use.</font>
<font color=#229933>// .unit             == the units or basic meaning of the data in the </font>
<font color=#229933>//                      specified output.</font>
<font color=#229933>// .hasFixedBinCount == true if each output feature (sample) has the </font>
<font color=#229933>//                      same dimension.</font>
<font color=#229933>// .binCount         == when hasFixedBinCount is true, then this is the </font>
<font color=#229933>//                      number of values in each output feature.  </font>
<font color=#229933>//                      binCount=0 if timestamps are the only features,</font>
<font color=#229933>//                      and they have no labels.</font>
<font color=#229933>// .binNames         == optional description of each bin in a feature.</font>
<font color=#229933>// .hasKnownExtent   == true if there is a fixed minimum and maximum</font>
<font color=#229933>//                      value for the range of the output.</font>
<font color=#229933>// .minValue         == range minimum if hasKnownExtent is true.</font>
<font color=#229933>// .maxValue         == range maximum if hasKnownExtent is true.</font>
<font color=#229933>// .isQuantized      == true if the data values are quantized.  Ignored</font>
<font color=#229933>//                      if binCount is set to zero.</font>
<font color=#229933>// .quantizeStep     == if isQuantized, then the size of the quantization,</font>
<font color=#229933>//                      such as 1.0 for integers.</font>
<font color=#229933>// .sampleType       == Enumeration with three possibilities:</font>
<font color=#229933>//   OD::OneSamplePerStep    -- output feature will be aligned with</font>
<font color=#229933>//                              the beginning time of the input block data.</font>
<font color=#229933>//   OD::FixedSampleRate     -- results are evenly spaced according to </font>
<font color=#229933>//                              .sampleRate (see below).</font>
<font color=#229933>//   OD::VariableSampleRate  -- output features have individual timestamps.</font>
<font color=#229933>// .sampleRate       == samples per second spacing of output features when</font>
<font color=#229933>//                      sampleType is set toFixedSampleRate.</font>
<font color=#229933>//                      Ignored if sampleType is set to OneSamplePerStep</font>
<font color=#229933>//                      since the start time of the input block will be used.</font>
<font color=#229933>//                      Usually set the sampleRate to 0.0 if VariableSampleRate</font>
<font color=#229933>//                      is used; otherwise, see vamp-sdk/Plugin.h for what</font>
<font color=#229933>//                      positive sampleRates would mean.</font>
<font color=#229933>//</font>

MzSpectrogramFFTW::OutputList 
MzSpectrogramFFTW::getOutputDescriptors(void) const {

   OutputList       list;
   OutputDescriptor od;

   <font color=#229933>// First and only output channel:</font>
   od.name             = "magnitude";
   od.description      = "Magnitude Spectrum";
   od.unit             = "decibels";
   od.hasFixedBinCount = true;
   od.binCount         = mz_maxbin - mz_minbin + 1;
   od.hasKnownExtents  = false;
   <font color=#229933>// od.minValue      = 0.0;</font>
   <font color=#229933>// od.maxValue      = 0.0;</font>
   od.isQuantized      = false;
   <font color=#229933>// od.quantizeStep  = 1.0;</font>
   od.sampleType       = OutputDescriptor::OneSamplePerStep;
   <font color=#229933>// od.sampleRate    = 0.0;</font>
   list.push_back(od);


   return list; 
}


<a name=initialise>
</a><font color=#229933>//////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzSpectrogramFFTW::initialise</b> -- this function is called once</font>
<font color=#229933>//     before the first call to process().</font>
<font color=#229933>//</font>

bool MzSpectrogramFFTW::initialise(size_t channels, size_t stepsize, 
      size_t blocksize) {

   if (channels &lt; getMinChannelCount() || channels &gt; getMaxChannelCount()) {
      return false;
   }

   <font color=#229933>// step size and block size should never be zero</font>
   if (stepsize &lt;= 0 || blocksize &lt;= 0) {
      return false;
   }

   setChannelCount(channels);
   setBlockSize(blocksize);
   setStepSize(stepsize);

   mz_minbin = getParameterInt("minbin");
   mz_maxbin = getParameterInt("maxbin");

   if (mz_minbin &gt;= getBlockSize()/2) { mz_minbin = getBlockSize()/2-1; }
   if (mz_maxbin &gt;= getBlockSize()/2) { mz_maxbin = getBlockSize()/2-1; }
   if (mz_maxbin &lt;  0)                { mz_maxbin = getBlockSize()/2-1; }
   if (mz_maxbin &lt;  mz_minbin)        { std::swap(mz_minbin, mz_maxbin); }

   <font color=#229933>// The signal size/transform size are equivalent for this</font>
   <font color=#229933>// plugin but the FFTW can handle any size transform.</font>
   <font color=#229933>// If the size of the transform is a multiple of small</font>
   <font color=#229933>// prime numbers the FFT will be used, otherwise it will</font>
   <font color=#229933>// be slow (when block size=1021 for example).</font>

   mz_transformer.setSize(getBlockSize());
   delete [] mz_wind_buff;
   mz_wind_buff = new double[getBlockSize()];
   makeHannWindow(mz_wind_buff, getBlockSize());

   return true;
}


<a name=process>
</a><font color=#229933>//////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzSpectrogramFFTW::process</b> -- This function is called sequentially on the </font>
<font color=#229933>//    input data, block by block.  After the sequence of blocks has been</font>
<font color=#229933>//    processed with process(), the function getRemainingFeatures() will </font>
<font color=#229933>//    be called.</font>
<font color=#229933>//</font>
<font color=#229933>// Here is a reference chart for the Feature struct:</font>
<font color=#229933>//</font>
<font color=#229933>// .hasTimestamp   == If the OutputDescriptor.sampleType is set to</font>
<font color=#229933>//                    VariableSampleRate, then this should be "true".</font>
<font color=#229933>// .timestamp      == The time at which the feature occurs in the time stream.</font>
<font color=#229933>// .values         == The float values for the feature.  Should match</font>
<font color=#229933>//                    OD::binCount.</font>
<font color=#229933>// .label          == Text associated with the feature (for time instants).</font>
<font color=#229933>//</font>

#define<a name=ABSSQUARE> </a><font color=#000000><b>ABSSQUARE</b></font>(x, y) ((x)*(x) + (y)*(y))
#define ZEROLOG         -120.0

MzSpectrogramFFTW::FeatureSet 
MzSpectrogramFFTW::process(float **inputbufs, Vamp::RealTime timestamp) {

   if (getChannelCount() &lt;= 0) {
      std::cerr &lt;&lt; "ERROR: MzSpectrogramFFTW::process: "
                &lt;&lt; "MzSpectrogramFFTW has not been initialized"
                &lt;&lt; std::endl;
      return FeatureSet();
   }

   <font color=#229933>// first window the input signal frame</font>
   windowSignal(mz_transformer, mz_wind_buff, inputbufs[0]);

   <font color=#229933>// then calculate the complex DFT spectrum. </font>
   mz_transformer.doTransform();

   <font color=#229933>// return the spectral magnitude frame to the host application:</font>

   FeatureSet returnFeatures;
   Feature    feature;
   feature.hasTimestamp = false;

   float magnitude;
   for (int i=mz_minbin; i&lt;=mz_maxbin; i++) {
      magnitude = (float)mz_transformer.getSpectrumMagnitudeDb(i);
      feature.values.push_back(magnitude);
   }

   returnFeatures[0].push_back(feature);

   return returnFeatures;
}


<a name=getRemainingFeatures>
</a><font color=#229933>//////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzSpectrogramFFTW::getRemainingFeatures</b> -- This function is called</font>
<font color=#229933>//    after the last call to process() on the input data stream has </font>
<font color=#229933>//    been completed.  Features which are non-causal can be calculated </font>
<font color=#229933>//    at this point.  See the comment above the process() function</font>
<font color=#229933>//    for the format of output Features.</font>
<font color=#229933>//</font>

MzSpectrogramFFTW::FeatureSet 
MzSpectrogramFFTW::getRemainingFeatures(void) {
   <font color=#229933>// no remaining features, so return a dummy feature</font>
   return FeatureSet();
}


<a name=reset>
</a><font color=#229933>//////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzSpectrogramFFTW::reset</b> -- This function may be called after data </font>
<font color=#229933>//    processing has been started with the process() function.  It will</font>
<font color=#229933>//    be called when processing has been interrupted for some reason and</font>
<font color=#229933>//    the processing sequence needs to be restarted (and current analysis</font>
<font color=#229933>//    output thrown out).  After this function is called, process() will</font>
<font color=#229933>//    start at the beginning of the input selection as if initialise()</font>
<font color=#229933>//    had just been called.  Note, however, that initialise() will NOT</font>
<font color=#229933>//    be called before processing is restarted after a reset().</font>
<font color=#229933>//</font>

void MzSpectrogramFFTW::reset(void) {
   <font color=#229933>// no actions necessary to reset this plugin</font>
}


<font color=#229933>///////////////////////////////////////////////////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// Non-Interface Functions </font>
<font color=#229933>//</font>

<a name=makeHannWindow>
</a><font color=#229933>//////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzSpectrogramFFTW::makeHannWindow</b> -- create a raised cosine (Hann)</font>
<font color=#229933>//     window.</font>
<font color=#229933>//</font>

void MzSpectrogramFFTW::makeHannWindow(double* output, int blocksize) {
   for (int i=0; i&lt;blocksize; i++) {
      output[i] = 0.5 - 0.5 * cos(2.0 * M_PI * i/blocksize);
   }
}


<a name=windowSignal>
</a><font color=#229933>//////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzSpectrogramFFTW::windowSignal</b> -- multiply the time signal</font>
<font color=#229933>//     by the analysis window to prepare for transformation.</font>
<font color=#229933>//</font>

void MzSpectrogramFFTW::windowSignal(MazurkaTransformer& transformer, 
      double* window, float* input) {
   int blocksize = transformer.getSize();
   for (int i=0; i&lt;blocksize; i++) {
      transformer.signalNonCausal(i) = window[i] * double(input[i]);
   }
}




</pre>


</td></tr>
</table>
</center>




</body>
</html>
   
