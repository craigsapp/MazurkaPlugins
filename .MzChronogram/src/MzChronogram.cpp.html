<!---------------------------------------------------------------------------->
<html>
<head>
<title> Sig++ example program: MzChronogram.cpp </title>
<meta name="Document-Owner" content="Craig Sapp (craig@ccrma.stanford.edu)"> 
<meta name="Author" content="Craig Stuart Sapp (craig@ccrma.stanford.edu)">
<meta name="Creation-Date" content=" Tue May  9 19:38:11 PDT 2000 ">
<meta name="Revision-Date" content=" Wed Dec 27 07:42:41 PST 2006
 ">
</head>

<body bgcolor=#ffffff alink=#333399 link=#333399 vlink=#333399 text=#220000>
<!-- header *************************************************** -->

<center>
<table width=760 cellpadding=0 cellspacing=0 border=0>
<tr valign=top>
<td>
   <a href=http://www.charm.rhul.ac.uk><img alt="" border=0 src=../../images/logo.gif></a>
</td>
<td>
   <a href=http://mazurka.org.uk><img alt="" border=0 src=../../images/banner.gif></a>
</td>
</tr>
</table>
</center>

<center>
<table><tr><td>


<pre>
<font color=#229933>//</font>
<font color=#229933>// Programmer:    Craig Stuart Sapp &lt;craig@ccrma.stanford.edu&gt;</font>
<font color=#229933>// Creation Date: Tue May  9 05:25:27 PDT 2006</font>
<font color=#229933>// Last Modified: Sat May 20 05:41:31 PDT 2006 (added parameters)</font>
<font color=#229933>// Last Modified: Thu May 25 22:27:53 PDT 2006 (added stereo diff & sensitivity)</font>
<font color=#229933>// Filename:      MzChronogram.cpp</font>
<font color=#229933>// URL:           <a href=http://sv.mazurka.org.uk/src/MzChronogram.cpp>http://sv.mazurka.org.uk/src/MzChronogram.cpp</a></font>
<font color=#229933>// Documentation: <a href=http://sv.mazurka.org.uk/MzChronogram>http://sv.mazurka.org.uk/MzChronogram</a></font>
<font color=#229933>// Syntax:        ANSI99 C++; vamp plugin</font>
<font color=#229933>//</font>
<font color=#229933>// Description:   Display audio signal in two dimensions.</font>
<font color=#229933>//</font>

#include "MzChronogram.h" 

#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;

#define SENSIZE      2001
#define MZSTEREO     -2
#define MZSTEREODIFF -1


<font color=#229933>///////////////////////////////////////////////////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// Vamp Interface Functions</font>
<font color=#229933>//</font>
<a name=constructor>
</a><font color=#229933>///////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzChronogram::MzChronogram</b> -- class constructor.</font>
<font color=#229933>//</font>

MzChronogram::MzChronogram(float samplerate) :<a name=MazurkaPlugin> </a><font color=#000000><b>MazurkaPlugin</b></font>(samplerate) {
   mz_whichchannel  =  MZSTEREO;
   mz_diffB         =  0;
   mz_lookup        = new float[SENSIZE];
}


<a name=destructor>
</a><font color=#229933>///////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzChronogram::~MzChronogram</b> -- class destructor.</font>
<font color=#229933>//</font>

MzChronogram::~MzChronogram() {
   delete [] mz_lookup;
}


<font color=#229933>////////////////////////////////////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// parameter functions --</font>
<font color=#229933>//</font>
<a name=getParameterDescriptors>
</a><font color=#229933>//////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzChronogram::getParameterDescriptors</b> -- return a list of</font>
<font color=#229933>//      the parameters which can control the plugin.</font>
<font color=#229933>//</font>

MzChronogram::ParameterList MzChronogram::getParameterDescriptors(void) const {

   ParameterList       pdlist;
   ParameterDescriptor pd;

   <font color=#229933>// first parameter: The number of samples on the vertical axis</font>
   pd.name         = "verticalperiod";
   pd.description  = "Vertical period";
   pd.unit         = "samples";
   pd.minValue     = 1.0;
   pd.maxValue     = 10000;
   pd.defaultValue = 100.0;
   pd.isQuantized  = true;
   pd.quantizeStep = 1.0;
   pdlist.push_back(pd);

   <font color=#229933>// second parameter: The Frequency of the period on the vertical axis</font>
   pd.name         = "frequency";
   pd.description  = "or Frequency";
   pd.unit         = "Hz";
   pd.minValue     = 0.0;
   pd.maxValue     = 10000.0;
   pd.defaultValue = 0.0;   
   pd.isQuantized  = false;
   <font color=#229933>// pd.quantizeStep = 0.0;</font>
   pdlist.push_back(pd);

   <font color=#229933>// third parameter: The Chroma for a frequency (base-12 pitch name)</font>
   pd.name         = "chroma";
   pd.description  = "or Chroma";
   pd.unit         = "";
   pd.minValue     = 0.0;
   pd.maxValue     = 12.0;
   pd.defaultValue = 12.0;   
   pd.isQuantized  = true;
   pd.quantizeStep = 1.0;
   <font color=#229933>// names for each quantized step:</font>
   pd.valueNames.push_back("C");
   pd.valueNames.push_back("C#");
   pd.valueNames.push_back("D");
   pd.valueNames.push_back("D#");
   pd.valueNames.push_back("E");
   pd.valueNames.push_back("F");
   pd.valueNames.push_back("F#");
   pd.valueNames.push_back("G");
   pd.valueNames.push_back("G#");
   pd.valueNames.push_back("A");
   pd.valueNames.push_back("A#");
   pd.valueNames.push_back("B");
   pd.valueNames.push_back("");
   pdlist.push_back(pd);
   pd.valueNames.clear();

   <font color=#229933>// fourth parameter: The Octave of a chroma</font>
   pd.name         = "octave";
   pd.description  = "+ Octave";
   pd.unit         = "";
   pd.minValue     = -1.0;
   pd.maxValue     = 9.0;
   pd.defaultValue = 0.0;   
   pd.isQuantized  = true;
   pd.quantizeStep = 1.0;
   pd.valueNames.push_back("-1");
   pd.valueNames.push_back("0");
   pd.valueNames.push_back("1");
   pd.valueNames.push_back("2");
   pd.valueNames.push_back("3");
   pd.valueNames.push_back("4");
   pd.valueNames.push_back("5");
   pd.valueNames.push_back("6");
   pd.valueNames.push_back("7");
   pd.valueNames.push_back("8");
   pd.valueNames.push_back("9");
   pdlist.push_back(pd);
   pd.valueNames.clear();

   <font color=#229933>// fifth parameter: Which channel(s) to display</font>
   pd.name         = "channelview";
   pd.description  = "Channel view";
   pd.unit         = "";
   pd.minValue     = -2.0;
   pd.maxValue     = 1.0;
   pd.defaultValue = -2.0;   
   pd.isQuantized  = true;
   pd.quantizeStep = 1.0;
   pd.valueNames.push_back("stereo");
   pd.valueNames.push_back("stereo difference");
   pd.valueNames.push_back("left channel");
   pd.valueNames.push_back("right channel");
   pdlist.push_back(pd);
   pd.valueNames.clear();

   <font color=#229933>// sixth parameter: Amplitude sensitivity</font>
   pd.name         = "sensitivity";
   pd.description  = "Sensitivity";
   pd.unit         = "";
   pd.minValue     = 0.0;
   pd.maxValue     = 1.0;
   pd.defaultValue = 0.0;   
   pd.isQuantized  = false;
   <font color=#229933>// pd.quantizeStep = 0.0;</font>
   pdlist.push_back(pd);

   return pdlist;
}


<font color=#229933>////////////////////////////////////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// optional polymorphic functions inherited from PluginBase:</font>
<font color=#229933>//</font>
<a name=getPreferredStepSize>
</a><font color=#229933>//////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzChronogram::getPreferredStepSize</b> -- overrides the </font>
<font color=#229933>//     default value of 0 (no preference) returned in the </font>
<font color=#229933>//     inherited plugin class.</font>
<font color=#229933>//</font>

size_t MzChronogram::getPreferredStepSize(void) const {
   return getPreferredBlockSize();
}


<a name=getPreferredBlockSize>
</a><font color=#229933>//////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzChronogram::getPreferredBlockSize</b> -- overrides the </font>
<font color=#229933>//     default value of 0 (no preference) returned in the </font>
<font color=#229933>//     inherited plugin class.</font>
<font color=#229933>//</font>

size_t MzChronogram::getPreferredBlockSize(void) const {
   float output = 0.0;
   float frequency, chroma, octave;
   if (!isParameterAtDefault("chroma")) {
      chroma = getParameterInt("chroma");
      octave = getParameterInt("octave");
      frequency = 440.0 * pow(2.0, ((chroma-9) + 12*(octave-4))/12.0);
      output = getSrate() / frequency;
   } else if (!isParameterAtDefault("frequency")) {
      frequency = getParameter("frequency");
      output = getSrate() / frequency;
   } else {
      output = getParameter("verticalperiod");
   }

   output = std::min(output, getParameterMax("verticalperiod"));
   output = std::max(output, getParameterMin("verticalperiod"));

   return size_t(output + 0.5);
}


<font color=#229933>////////////////////////////////////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// required polymorphic functions inherited from PluginBase:</font>
<font color=#229933>//</font>

std::string MzChronogram::getName(void) const
   { return "mzchronogram"; }

std::string MzChronogram::getMaker(void) const
   { return "The Mazurka Project"; }

std::string MzChronogram::getCopyright(void) const
   { return "2006 Craig Stuart Sapp"; }

std::string MzChronogram::getDescription(void) const
   { return "Chronogram"; }

int MzChronogram::getPluginVersion(void) const {
   #define P_VER    "200605270"
   #define P_NAME   "MzChronogram"

   const char *v = "@@VampPluginID@" P_NAME "@" P_VER "@" __DATE__ "@@";
   if (v[0] != '@') { std::cerr &lt;&lt; v &lt;&lt; std::endl; return 0; }

   return atol(P_VER);
}


<font color=#229933>////////////////////////////////////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// required polymorphic functions inherited from Plugin:</font>
<font color=#229933>//</font>
<a name=getInputDomain>
</a><font color=#229933>//////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzChronogram::getInputDomain</b> -- the host application needs</font>
<font color=#229933>//    to know if it should send either:</font>
<font color=#229933>//</font>
<font color=#229933>// TimeDomain      == Time samples from the audio waveform.</font>
<font color=#229933>// FrequencyDomain == Spectral frequency frames which will arrive</font>
<font color=#229933>//                    in an array of interleaved real, imaginary</font>
<font color=#229933>//                    values for the complex spectrum (both positive </font>
<font color=#229933>//                    and negative frequencies). Zero Hz being the</font>
<font color=#229933>//                    first frequency sample and negative frequencies</font>
<font color=#229933>//                    at the far end of the array as is usually done.</font>
<font color=#229933>//                    Note that frequency data is transmitted from</font>
<font color=#229933>//                    the host application as floats.  The data will</font>
<font color=#229933>//                    be transmitted via the process() function which</font>
<font color=#229933>//                    is defined further below.</font>
<font color=#229933>//</font>

MzChronogram::InputDomain MzChronogram::getInputDomain(void) const { 
   return TimeDomain; 
}


<a name=getOutputDescriptors>
</a><font color=#229933>//////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzChronogram::getOutputDescriptors</b> -- return a list describing</font>
<font color=#229933>//    each of the available outputs for the object.  OutputList</font>
<font color=#229933>//    is defined in the file vamp-sdk/Plugin.h:</font>
<font color=#229933>//</font>
<font color=#229933>// .name             == short name of output for computer use.  Must not</font>
<font color=#229933>//                      contain spaces or punctuation.</font>
<font color=#229933>// .description      == long name of output for human use.</font>
<font color=#229933>// .unit             == the units or basic meaning of the data in the </font>
<font color=#229933>//                      specified output.</font>
<font color=#229933>// .hasFixedBinCount == true if each output feature (sample) has the </font>
<font color=#229933>//                      same dimension.</font>
<font color=#229933>// .binCount         == when hasFixedBinCount is true, then this is the </font>
<font color=#229933>//                      number of values in each output feature.  </font>
<font color=#229933>//                      binCount=0 if timestamps are the only features,</font>
<font color=#229933>//                      and they have no labels.</font>
<font color=#229933>// .binNames         == optional description of each bin in a feature.</font>
<font color=#229933>// .hasKnownExtent   == true if there is a fixed minimum and maximum</font>
<font color=#229933>//                      value for the range of the output.</font>
<font color=#229933>// .minValue         == range minimum if hasKnownExtent is true.</font>
<font color=#229933>// .maxValue         == range maximum if hasKnownExtent is true.</font>
<font color=#229933>// .isQuantized      == true if the data values are quantized.  Ignored</font>
<font color=#229933>//                      if binCount is set to zero.</font>
<font color=#229933>// .quantizeStep     == if isQuantized, then the size of the quantization,</font>
<font color=#229933>//                      such as 1.0 for integers.</font>
<font color=#229933>// .sampleType       == Enumeration with three possibilities:</font>
<font color=#229933>//   OD::OneSamplePerStep   -- output feature will be aligned with</font>
<a name=VariableSampleRate><font color=#229933>//                             the beginning time of the input block data.</font>
</a><font color=#229933>//   OD::FixedSampleRate    -- results are evenly spaced according to </font>
<font color=#229933>//                             .sampleRate (see below).</font>
<font color=#229933>//   <b>OD::VariableSampleRate</b> -- output features have individual timestamps.</font>
<font color=#229933>// .sampleRate       == samples per second spacing of output features when</font>
<font color=#229933>//                      sampleType is set toFixedSampleRate.</font>
<font color=#229933>//                      Ignored if sampleType is set to OneSamplePerStep</font>
<font color=#229933>//                      since the start time of the input block will be used.</font>
<font color=#229933>//                      Usually set the sampleRate to 0.0 if VariableSampleRate</font>
<font color=#229933>//                      is used; otherwise, see vamp-sdk/Plugin.h for what</font>
<font color=#229933>//                      positive sampleRates would mean.</font>
<font color=#229933>//</font>

MzChronogram::OutputList MzChronogram::getOutputDescriptors(void) const {

   OutputList       odlist;
   OutputDescriptor od;

   <font color=#229933>// First and only output channel:</font>
   od.name             = "chronogram";
   od.description      = "Chronogram";
   od.unit             = "";
   od.hasFixedBinCount = true;
   if (getParameterInt("channelview") == MZSTEREO) {
      od.binCount = getBlockSize() * getChannelCount(); <font color=#229933>// stereo display</font>
   } else {  
      od.binCount = getBlockSize();                 <font color=#229933>// mono display</font>
   }
   od.hasKnownExtents  = false;
   <font color=#229933>// od.minValue      = 0.0;</font>
   <font color=#229933>// od.maxValue      = 0.0;</font>
   od.isQuantized      = false;
   <font color=#229933>// od.quantizeStep  = 1.0;</font>
   od.sampleType       = OutputDescriptor::OneSamplePerStep;
   <font color=#229933>// od.sampleRate    = 0.0;</font>
   odlist.push_back(od);

   return odlist; 
}


<a name=initialise>
</a><font color=#229933>//////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzChronogram::initialise</b> -- this function is called once</font>
<font color=#229933>//     before the first call to process().</font>
<font color=#229933>//</font>

bool MzChronogram::initialise(size_t channels, size_t stepsize, 
      size_t blocksize) {

   if (channels &lt; getMinChannelCount() || channels &gt; getMaxChannelCount()) {
      return false;
   }

   <font color=#229933>// step size and block size should never be zero</font>
   if (stepsize &lt;= 0 || blocksize &lt;= 0) {
      return false;
   }

   <font color=#229933>// Only one copy of a particular sample should be displayed.</font>
   <font color=#229933>// If the step size is smaller than the block size, pretend</font>
   <font color=#229933>// that the block size is the same as the step size.</font>
   setBlockSize(std::min(stepsize, blocksize));
   setStepSize(stepsize);
   setChannelCount(channels);

   mz_whichchannel = getParameterInt("channelview");
   if (mz_whichchannel &gt;= getChannelCount()) {
      mz_whichchannel = getChannelCount() - 1;
   }

   <font color=#229933>// If stereo (or higher),  channel 1 will be subtracted from channel 0</font>
   <font color=#229933>// when doing stereo diff display.</font>
   if (getChannelCount() &gt;= 1) {
      mz_diffB = 1;
   } else {
      <font color=#229933>// monophonic input, so subtract from itself.</font>
      mz_diffB = 0;
   }

   buildLookupTable(mz_lookup, SENSIZE, getParameter("sensitivity"));

   return true;
}


<a name=process>
</a><font color=#229933>//////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzChronogram::process</b> -- This function is called sequentially on the </font>
<font color=#229933>//    input data, block by block.  After the sequence of blocks has been</font>
<font color=#229933>//    processed with process(), the function getRemainingFeatures() will </font>
<font color=#229933>//    be called.</font>
<font color=#229933>//</font>
<font color=#229933>// Here is a reference chart for the Feature struct:</font>
<font color=#229933>//</font>
<font color=#229933>// .hasTimestamp   == If the OutputDescriptor.sampleType is set to</font>
<font color=#229933>//                    VariableSampleRate, then this should be "true".</font>
<font color=#229933>// .timestamp      == The time at which the feature occurs in the time stream.</font>
<font color=#229933>// .values         == The float values for the feature.  Should match</font>
<font color=#229933>//                    OD::binCount.</font>
<font color=#229933>// .label          == Text associated with the feature (for time instants).</font>
<font color=#229933>//</font>

MzChronogram::FeatureSet MzChronogram::process(float **inputbufs, 
      Vamp::RealTime timestamp) {

   if (getStepSize() &lt;= 0) {
      std::cerr &lt;&lt; "ERROR: MzChronogram::process: "
                &lt;&lt; "MzChronogram has not been initialized"
                &lt;&lt; std::endl;
      return FeatureSet();
   }

   FeatureSet returnFeatures;
   Feature feature;

   if (mz_whichchannel == MZSTEREO ) {
      feature.values.resize(getChannelCount() * getBlockSize());
   } else {
      feature.values.resize(getBlockSize());
   }
      
   feature.hasTimestamp = false;

   <font color=#229933>// The Chronogram display has to be turned "upside-down" so that </font>
   <font color=#229933>// steeper downward slopes indicate flatter notes, and steeper </font>
   <font color=#229933>// higher slopes indicate sharper notes.</font>

   int chan, samp;
   float sample;
   int i = 0;

   switch (mz_whichchannel) {
      case MZSTEREO:
         for (chan=getChannelCount()-1; chan&gt;=0; chan--) {
            for (samp=getBlockSize()-1; samp&gt;=0; samp--) {
               sample = inputbufs[chan][samp];
               if      (sample &lt; -1.0) { sample = -1.0; }
               else if (sample &gt; +1.0) { sample = +1.0; }
               sample = mz_lookup[int((sample+1)/2*(SENSIZE-1))];
               feature.values[i++] = sample;
            }
         }
         break;

      case MZSTEREODIFF:
         <font color=#229933>// stereo difference display</font>
         for (samp=getBlockSize()-1; samp&gt;=0; samp--) {
            sample = inputbufs[0][samp] - inputbufs[mz_diffB][samp];
            if      (sample &lt; -2.0) { sample = -2.0; }
            else if (sample &gt; +2.0) { sample = +2.0; }
            sample = mz_lookup[int((sample+2)/4*(SENSIZE-1))];
            feature.values[i++] = sample;
         }
         break;

      default:
         <font color=#229933>// monophonic display</font>
         for (samp=getBlockSize()-1; samp&gt;=0; samp--) {
            sample = inputbufs[mz_whichchannel][samp];
            if      (sample &lt; -1.0) { sample = -1.0; }
            else if (sample &gt; +1.0) { sample = +1.0; }
            sample = mz_lookup[int((sample+1)/2*(SENSIZE-1))];
            feature.values[i++] = sample;
         }
   }

   returnFeatures[0].push_back(feature);

   return returnFeatures;
}


<a name=getRemainingFeatures>
</a><font color=#229933>//////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzChronogram::getRemainingFeatures</b> -- This function is called</font>
<font color=#229933>//    after the last call to process() on the input data stream has </font>
<font color=#229933>//    been completed.  Features which are non-causal can be calculated </font>
<font color=#229933>//    at this point.  See the comment above the process() function</font>
<font color=#229933>//    for the format of output Features.</font>
<font color=#229933>//</font>

MzChronogram::FeatureSet MzChronogram::getRemainingFeatures(void) {
   <font color=#229933>// no remaining features, so return a dummy feature</font>
   return FeatureSet();
}


<a name=reset>
</a><font color=#229933>//////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzChronogram::reset</b> -- This function may be called after data processing</font>
<font color=#229933>//    has been started with the process() function.  It will be called when</font>
<font color=#229933>//    processing has been interrupted for some reason and the processing</font>
<font color=#229933>//    sequence needs to be restarted (and current analysis output thrown out).  </font>
<font color=#229933>//    After this function is called, process() will start at the beginning</font>
<font color=#229933>//    of the input selection as if initialise() had just been called.</font>
<font color=#229933>//    Note, however, that initialise() will NOT be called before processing </font>
<font color=#229933>//    is restarted after a reset().</font>
<font color=#229933>//</font>

void MzChronogram::reset(void) {
   <font color=#229933>// no actions necessary to reset this plugin</font>
}


<font color=#229933>///////////////////////////////////////////////////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// Non-Interface Functions </font>
<font color=#229933>//</font>

<a name=buildLookupTable>
</a><font color=#229933>//////////////////////////////</font>
<font color=#229933>//</font>
<font color=#229933>// <b>MzChronogram::buildLookupTable</b> -- Compresses the audio so that smaller</font>
<font color=#229933>//     amplitudes can be seen as well (or nearly as well) as</font>
<font color=#229933>//     larger amplitudes.  If the sensitivity is 0.0, then the sound data</font>
<font color=#229933>//     is unaltered.  If the sensitivity is 1.0, then most posititive </font>
<font color=#229933>//     amplitudes are mapped to positive max, and negative amplitudes</font>
<font color=#229933>//     are mapped to negative max.</font>
<font color=#229933>//</font>


#define<a name=MZSIG> </a><font color=#000000><b>MZSIG</b></font>(x,w)      (1.0/(1.0+exp(-(x)/(w))))
#define<a name=MZSINSIG> </a><font color=#000000><b>MZSINSIG</b></font>(x,w)   (<a href=#MZSIG>MZSIG</a>(x,w) + sin((x)*(w)) * <a href=#MZSIG>MZSIG</a>(1,(w)) - 0.5)
#define<a name=MZSCALING> </a><font color=#000000><b>MZSCALING</b></font>(x,w)  (<a href=#MZSINSIG>MZSINSIG</a>(x,w)/<a href=#MZSINSIG>MZSINSIG</a>(1,w) - 0.04 * sin(M_PI * (x)))

void MzChronogram::buildLookupTable(float* buffer, int size, float sensitivity) 
{
 
   <font color=#229933>// flip and scale the sensitivity factor</font>
   if      (sensitivity &gt; 1.0) { sensitivity = 1.0; } 
   else if (sensitivity &lt; 0.0) { sensitivity = 0.0; } 
   double weight = (1.0 - pow(double(sensitivity), 0.125)) * 0.84 + 0.005;

   if (sensitivity == 0.0) {
      for (int i=0; i&lt;size; i++) {
         buffer[i] = float(2.0 * i/(size-1.0) - 1.0);
      }
   } else {
      for (int i=0; i&lt;size; i++) {
         buffer[i] = float(<a href=#MZSCALING>MZSCALING</a>(2.0 * i/(size-1.0) - 1.0, weight));
      }
   }
}



</pre>


</td></tr>
</table>
</center>




</body>
</html>
   
